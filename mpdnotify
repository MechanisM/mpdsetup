#!/usr/bin/env python
# Newer, shinier mpdnotify using Python!
# Coded on the night of Thu, Jun 25, 2009 (10:15 PM to be exact!)
# JP St. Pierre <jstpierre@mecheye.net>

# Requires:
#   
#   mpd >= 0.14
#   
#   pynotify
#   
#   mpd-python (latest development build)
#     found at http://git.thejat.be/python-mpd.git/
#   
#   pygtk (for icon finding)
#   
#   configobj (for config reading)
#     comes with bzr, you can also easy_install configobj

import sys
import os
import cgi
import pynotify
import urllib2

from PIL import Image
from configobj import ConfigObj, Section
from string import Template
from mpd import MPDClient, ConnectionError
from socket import error as SocketError

pretty_state = dict(play="Playing", pause="Paused", stop="Stopped")

# string.Template subclass for parsing %artist% templates like
# those used by mpc and foobar.
class PercentTemplate(Template):
    pattern = "%(?P<named>[_a-z][_a-z0-9]*)%"


def str_fn_index(s, fn, arg):
    if isinstance(arg, basestring):
        arg = arg,
    arg = iter(arg)
    for i, m in enumerate(arg):
        if fn(s.lower(), m.lower()):
            return True, i
    return False, None

class CoverBackend(object):
    def __init__(self, config):
        pass
    
    def get_icon(self, opts):
        return None, None

    def resize_image(self, filename):
        cover_small  = "%s.small%s" % os.path.splitext(filename)
        
        if not os.path.exists(cover_small):
            try:
                img = Image.open(filename)
                img.thumbnail(cover_size, Image.ANTIALIAS)
                img.save(cover_small)
            except IOError:
                return None
    
        return cover_small

class AmazonBackend(CoverBackend):
    URL = "http://images.amazon.com/images/P/%s.01._SCLZZZZZZZ_.jpg"
    def __init__(self, config):
        from pyaws import ecs
        ecs.setLicenseKey(config["api_key"])
        ecs.setSecretAccessKey(config["secret_key"])
        self.ecs = ecs

    
    def get_icon(self, opts):
        try:
            result = self.ecs.ItemSearch(opts['album'], Artist=opts['artist'], SearchIndex="Music")
            result = result[0]
            filename = os.path.join(os.path.expanduser("~/.covers"),
                                    opts['artist'].replace("/", " "),
                                    "%s.jpg" % opts['album'].replace("/", " "))
            return filename, result
        
        except (KeyError, self.ecs.SignatureDoesNotMatch), e:
            return None, None

    def handle_async(self, filename, result):
        os.mkdir(os.path.split(filename)[0])
        handle = open(filename, "w")
        art = urllib2.urlopen(self.URL % result.ASIN)
        handle.write(art.read())
        handle.close()
        
class MusicDirBackend(CoverBackend):
    def __init__(self, config):
        self.cover_names = make_list(config['search_names'])
        self.cover_exts  = make_list(config['search_exts'])
        self.music_path  = os.path.realpath(os.path.expanduser(config['music_path']))
        
    def get_icon(self, opts):
        path   = os.path.dirname(os.path.join(self.music_path, opts['file']))
        covers = dict()

        for filename in os.listdir(path):
            # This weights by the order in the cover_names, but also so that
            # a shorter filename comes first, so we won't end up choosing
            # cover.small.jpg
            b1, i1 = str_fn_index(filename, str.startswith, self.cover_names)
            b2, i2 = str_fn_index(filename, str.endswith, self.cover_exts)
            if b1 and b2:
                covers[(i1+i2)*100+len(filename)] = filename

        if covers:
            cover = sorted(covers.items())[0][1]
            return os.path.join(path, cover), None

        return None, None

class CoversDirBackend(CoverBackend):
    def get_icon(self, opts):
        if 'artist' not in opts or 'album' not in opts:
            return None
        
        cover = os.path.join(os.path.expanduser("~/.covers"),
                             opts['artist'].replace("/", " "),
                             "%s.jpg" % opts['album'].replace("/", " "))
        
        if os.path.exists(cover):
            return cover, None
        
        return None, None

class GTKIconThemeBackend(CoverBackend):
    def __init__(self, config):
        import gtk
        self.icon_theme = gtk.icon_theme_get_default()

    def get_icon(self, opts):
        if opts['icon']:
            icon = self.icon_theme.lookup_icon(opts['icon'], 96, 0)
            if icon:
                return icon.get_filename(), None
        return None, None

BACKENDS = dict()
BACKENDS["amazon"]   = AmazonBackend
BACKENDS["musicdir"] = MusicDirBackend
BACKENDS[".covers"]  = CoversDirBackend
BACKENDS["icons"]    = GTKIconThemeBackend

def make_list(v):
    try:
        v[0]
        return v
    except TypeError:
        return [v]

config = ConfigObj(os.path.expanduser("~/.mpdnotify.conf"))

covers_config = config['covers']

cover_size      = tuple(int(n) for n in covers_config['size'])

backends = []

for backend in make_list(covers_config['cover_backends']):
    backends.append(BACKENDS[backend](config.get('covers:backend:'+backend, {})))

pynotify.init("mpdnotify")

client = MPDClient()
client.connect(config['daemon']['host'], config['daemon']['port'])

# Hack for string.Template and the KeyError problem.
# Substitute a default instead of throwing a KeyError.
def template_substitute_default(self, args, default=''):
    while True:
        try:
            return self.substitute(args)
        except KeyError, e:
            args[e.args[0]] = default

Template.substitute_default = template_substitute_default

def get_opts(joiner):
    
    def parse_time(opts):
        if "time" in opts:
            elapsed, duration = (divmod(int(n), 60) for n in opts['time'].split(":"))
            return dict(elapsed="%d:%02d" % elapsed, duration="%d:%02d" % duration)
        return dict()
    
    opts = dict()
    
    opts.update(client.status())
    opts.update(parse_time(opts))
    opts.update(client.stats())
    opts.update(client.currentsong())
    opts.update(dict(pretty_state=pretty_state[opts['state']]))
    
    # If we have multiple tags, join them.
    for key, val in opts.iteritems():
        if isinstance(val, list):
            opts[key] = joiner.join(val)
    
    return opts

def display_notification(title, body, enable_covers=True, tags_joiner=', ', icon=None):
    # And format our stuff.
    title_format = PercentTemplate(title)
    body_format  = PercentTemplate(body)
    
    opts = get_opts(tags_joiner)
    opts['icon'] = icon
    
    # Covers are enabled.
    if enable_covers and "file" in opts:
        
        loading = False
        for backend in backends:
            cover, async = backend.get_icon(opts)
                
            if cover:
                break
            
        if cover and os.path.exists(cover):
            cover = backend.resize_image(cover)
    
    title = title_format.substitute_default(opts)
    body  = cgi.escape(body_format.substitute_default(opts))

    final_image = cover
    if async:
        final_image = None
    
    # And launch the notification!
    notification = pynotify.Notification(title, body, final_image)
    notification.show()

    if async:
        backend.handle_async(cover, async)
        cover = backend.resize_image(cover)
        
    notification.update(title, body, cover)
    notification.show()

def display_notification_config(config_name):
    # If we don't want to display a notification,
    # don't do so.
    if "notification_%s" % config_name not in config:
        return
    
    # Get our configuration
    not_cfg = config["notification_%s" % config_name]
    title       = not_cfg.get("title_format", "")
    body        = not_cfg.get("body_format",  "")
    tags_joiner = not_cfg.get("tags_joiner",  ", ")
    covers      = not_cfg.get("covers",       False)
    icon        = not_cfg.get("icon",         "")
    
    display_notification(title, body, covers, tags_joiner, icon)

def daemon():
    global client
    if tuple(int(m) for m in client.mpd_version.split('.')) < (0, 14, 0):
        print "You need a version of mpd that is 0.14 or greater"
        sys.exit(1)
    try:
        while True:

            
            client = MPDClient()
            client.connect(config['daemon']['host'], config['daemon']['port'])
            
            try:
                # Idle for a reason.
                reasons = client.idle()
            
                for reason in reasons:
                    # Show the notitication
                    display_notification_config(reason)
                    
            except (ConnectionError, SocketError), e:
                continue
            
    except KeyboardInterrupt:
        pass

def help_command(command=""):
    if command == "":
        print "mpdnotify - JP St. Pierre <jstpierre@mecheye.net>"
        print "email me or post comments on the wiki, or msg me on #mpd"
        print "for feature suggestions for this program. I go by the alias magcius."
        print ""
        print "commands:"
        print "  help    - display this message"
        print "  display - put up a notification"
    elif command == "display":
        print "  display - put up a notification"
        print "    display config_name"
        print "      display a notification where notification_$config_name"
        print "      is a format defined in ~/.mpdnotify.conf"
        print ""
        print "    display title [body] [icon]"
        print "      display a notification having those title, body, and icon"
        print '      use the name "cover" for the icon parameter if you want'
        print "      to show cover art"

def display_notification_command(arg1="", body="", icon=""):
    if ("notification_%s" % arg1) in config:
        display_notification_config(arg1)
    else:
        display_notification(arg1, body, icon == "cover", "", icon)

COMMANDS = {
    "help":     help_command,
    "display":  display_notification_command
}

if __name__ == "__main__":
    
    if len(sys.argv) < 2:
        # Start daemon.
        # Here we go.
        daemon()
        sys.exit(1)
        
    else:
        command = sys.argv[1].lower().lstrip("-")
        if command in COMMANDS:
            args = sys.argv[2:] if len(sys.argv) > 2 else ()
            COMMANDS[command](*args)
        else:
            print "no command by that name"
            print "use the 'help' command for available commands"
